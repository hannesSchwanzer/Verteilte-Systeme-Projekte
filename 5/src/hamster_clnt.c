/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "hamster.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

int *
hamster_new_1(hamster_new_arg *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, HAMSTER_NEW,
		(xdrproc_t) xdr_hamster_new_arg, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
hamster_lookup_1(hamster_lookup_arg *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, HAMSTER_LOOKUP,
		(xdrproc_t) xdr_hamster_lookup_arg, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

hamster_directory_ret *
hamster_directory_1(hamster_directory_arg *argp, CLIENT *clnt)
{
	static hamster_directory_ret clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, HAMSTER_DIRECTORY,
		(xdrproc_t) xdr_hamster_directory_arg, (caddr_t) argp,
		(xdrproc_t) xdr_hamster_directory_ret, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

hamster_howsdoing_ret *
hamster_howsdoing_1(int *argp, CLIENT *clnt)
{
	static hamster_howsdoing_ret clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, HAMSTER_HOWSDOING,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_hamster_howsdoing_ret, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

hamster_readentry_ret *
hamster_readentry_1(int *argp, CLIENT *clnt)
{
	static hamster_readentry_ret clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, HAMSTER_READENTRY,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_hamster_readentry_ret, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
hamster_givetreats_1(hamster_givetreats_arg *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, HAMSTER_GIVETREATS,
		(xdrproc_t) xdr_hamster_givetreats_arg, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
hamster_collect_1(hamster_collect_arg *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, HAMSTER_COLLECT,
		(xdrproc_t) xdr_hamster_collect_arg, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
